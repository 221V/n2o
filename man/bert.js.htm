<html>

<head>
    <meta charset="utf-8" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="" />
    <meta name="author" content="Maxim Sokhatsky" />
    <title>BERT.JS</title>
    <link rel="stylesheet" href="https://synrc.space/synrc.css" />
</head>

<body>

<nav>
    <a href='https://synrc.space/'>SYNRC</a>
    <a href='https://n2o.space'>N2O ECO</a>
    <a href='../index.html'>N2O</a>
</nav>

<header>
    <a href="../index.html"><img src="https://n2o.space/img/Synrc Neo.svg"></a>
    <h1>BERT.JS</h1>
</header>

<main>
    <section>
        <h3>INTRO</h3>

        <p>The <b>bert.js</b> module provides JavaScript encoder/decoder for
        <a href="http://erlang.org/doc/apps/erts/erl_ext_dist.html">External Term Format</a> used in Erlang distribution protocol. That means
        your JavaScript applications talk to Erlang natively. This module
        uses <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView">DataView</a> and
        <b>getUint8</b>, <b>getUint16</b>, <b>getUint32</b> word accessors which is
        the fastest way of dealing with binaries in JavaScript.
        The library is used in Erang and Haskell N2O versions.
        The size of <b>bert.js</b> is 3363 bytes.</p>

        <p>Note that this library is low-level, fast version
           of BERT encoder/decoder. If you want to generate
           JavaScript SDK with field names as in Erlang include
           files, take <a href="https://synrc.github.io/bert">BERT</a>
           as high-level counterpart library that generates
           wrappers around <b>bert.js</b> and provides
           more slick JavaScript experience.</p>
        <p>Erlang structure that compiles to BERT format:</p>
        <figure><code>
 #io{ code = login,
      data = { 'Token', 42 } }
        </code></figure>
           <p>Target structure of <a href="#">bert.js</a> &mdash; fast low-level handcoded parser from BERT format.<p>
        <figure><code>
 { t: 104,
   v: [ { t: 100, v: "io" },
        { t: 100, v: "login" },
        { t: 104, v: [ { t: 100, v: "Token" },
                       { t: 97,  v: 42 } ] } ] }
        </code></figure>
           <p>Target structure of generated parser with <a href="https://synrc.github.io/bert">BERT</a> parse transform:<p>
        <figure><code>
 { tup: 'io',
   code: 'login',
   data: { tup: '$',
           0: 'Token',
           1: 42 } },
        </code></figure>
    </section>
    <section>
        <h3>API</h3>
        <h4>end(json)</h4>
        <h4>dec(buffer)</h4>
        <h4>tuple(x,y,...)</h4>
        <h4>list(x,y,...)</h4>
        <h4>bin(x)</h4>
        <h4>atom(x)</h4>
    </section>
    <section>
        <h3></h3>
        <p>Decoding table:</p>
        <figure><code>
 function din() {
   var c = sx.getUint8(ix++), x; switch (c) {
       case  97: x = [int, 1]; break; case  98: x = [int, 4]; break;
       case 100: x = [str, 2]; break; case 104: x = [run, 1]; break;
       case 107: x = [arr, 2]; break; case 108: x = [run, 4]; break;
       case 109: x = [str, 4]; break; case 110: x = [big, 1]; break;
       case 111: x = [big, 4]; break; case 115: x = [str, 1]; break;
       case 118: x = [str, 2]; break; case 119: x = [str, 1]; break;
       default:  x = [nop, 0];
   } return { t: c, v: x[0](x[1]) };
 };
        </code></figure>
    </section>
    <section>
        <h3>97</h3>
        <p>Byte encoding. Unsigned 8-bit integer.</p>
        <figure><code>
 1    1
 97   Int
        </code></figure>
    </section>
    <section>
        <h3>98</h3>
        <p>Integer encoding. Signed 32-bit integer in big-endian format.</p>
        <figure><code>
 1    4
 98   Int
        </code></figure>
    </section>
    <section>
        <h3>100</h3>
        <p>Atom encoding. An atom is stored with a 2 byte unsigned length in big-endian order,
           followed by N numbers of 8-bit Latin-1 characters that forms the name.
           The maximum allowed value for Len is 255.</p>
        <figure><code>
 1    2    N
 100  N    Characters
        </code><figure>
    </section>
    <section>
        <h3>104</h3>
        <p>Tuple encoding. The Arity field is an unsigned byte N that determines
           how many elements that follows in section Elements.</p>
        <figure><code>
 1    1    N
 104  N    Elements
        </code><figure>
    </section>
    <section>
        <h3>106</h3>
        <p>Nil.</p>
        <figure><code>
 1
 106
        </code></figure>
    </section>
    <section>
        <h3>107</h3>
        <p>String encoding. As field N is an unsigned 2
           byte integer (big-endian), implementations must ensure that lists longer
           than 65535 elements are encoded as 108.
        </p>
        <figure><code>
 1    2    N
 107  N    Characters
        </code><figure>
    </section>
    <section>
        <h3>108</h3>
        <p>List encoding. N is the number of elements that follows in section Characters.
           Tail is the final tail of the list; it is 106 for a proper list,
           but can be any type if the list is improper (for example, [a|b]).
        </p>
        <figure><code>
 1    4    N
 108  N    Characters  Tail
        </code><figure>
    </section>
    <section>
        <h3>109</h3>
        <p>Binary encoding. Binaries are generated with bit syntax expression or with
           erlang:list_to_binary/1, erlang:term_to_binary/1, or as
           input from binary ports. The N length field is an unsigned
           4 byte integer (big-endian).
        </p>
        <figure><code>
 1    4    N
 109  N    Bytes
        </code><figure>
    </section>
    <section>
        <h3>110</h3>
        <p>Small bignum encoding. Bignums are stored in unary form with a Sign byte, that is,
           0 if the binum is positive and 1 if it is negative.
           The digits are stored with the least significant byte stored first.
           To calculate the integer, the following formula can be used:</p>
        <figure><code>
 1    1    1    n
 111  n    Sign d(0)...d(n-1)
        </code></figure>
        <p>
 B = 256,<br>
     d<sub>0</sub>*B<sup>0</sup>
   + d<sub>1</sub>*B<sup>1</sup>
   + d<sub>2</sub>*B<sup>2</sup>
   + ... d<sub>N-1</sub>*B<sup>(n-1)</sup>
 </p>
    </section>
    <section>
        <h3>111</h3>
        <p>Large bignum encoding.
           Same as 110 except that the length field is an unsigned 4 byte integer.</p>
        <figure><code>
 1    4    1    n
 111  n    Sign d(0)...d(n-1)
        </code></figure>
    </section>
    <section>
        <h3>115</h3>
        <p>Small atom encoding. An atom is stored with a 1 byte unsigned
           length, followed by N numbers of 8-bit Latin-1 characters
           that forms the Characters.
        </p>
        <figure><code>
 1    1    N
 115  N    Characters
        </code><figure>
    </section>
    <section>
        <h3>118</h3>
        <p>UTF8 atom encoding. An atom is stored with a 2 byte unsigned
           length in big-endian order, followed by Len bytes containing
           the Characters encoded in UTF-8.
        </p>
        <figure><code>
 1    2    N
 118  N    Characters
        </code><figure>
    </section>
    <section>
        <h3>119</h3>
        <p>UTF8 small atom encoding. An atom is stored with a 1 byte unsigned
           length, followed by Len bytes containing the Characters encoded in UTF-8.
           Longer atoms encoded in UTF-8 can be represented using 118.
        </p>
        <figure><code>
 1    1    N
 119  N    Characters
        </code><figure>
    </section>
    <section>

<p>You may also want to read:
<b>
<a href="utf8.js.htm">utf8.js</a></b>,
<a href="bullet.js.htm">bullet.js</a></b>,
<a href="n2o.js.htm">n2o.js</a></b>.
</p>

    </section>
</main>

<footer>
    2005&mdash;2018 &copy; Synrc Research Center
</footer>

</body>
</html>
