\section{API}

\subsection{Update DOM \bf{wf:update}}
You can update part of the page or DOM element with given element or even raw HTML.
Also you can use {\bf \#dtl} or {\bf \#eex} template elements for HTML generation to replace.
Here is example of simple {\bf \#span} or {\bf \#br} elements which are HTML counterparts:

\vspace{1\baselineskip}
\begin{lstlisting}
    wf:update(history,[#span{body="Hello"},#br{}]).
\end{lstlisting}
\vspace{1\baselineskip}

It generates DOM update script and sends it to WebSockets for evaluation.

\vspace{1\baselineskip}
\begin{lstlisting}
    $('#history').html('<span>Hello</span><br>').
\end{lstlisting}
\vspace{1\baselineskip}

Companions are also provided for updating head and tail of the list: {\bf wf:top/2}
and {\bf wf:bottom/2} along with {\bf wf:before\/2} and {\bf wf:after/2}
for relative updates. For remove element you should use {\bf wf:remove/2}.

\paragraph{}
Full lists of elements you can use as second paramenter to update functions you can find in {\bf Section 7}.

\subsection{Wire JavaScript \bf{wf:wire}}
When you need embedding of JavaScript you can use direct wiring

\vspace{1\baselineskip}
\begin{lstlisting}
    wf:wire("$('#history').scrollTop = $('#history').scrollHeight;").
\end{lstlisting}
\vspace{1\baselineskip}

Or you can wire actions which are rendered to JavaScript through common render.
Here is example command that shows debug window at the bottom of the page:

\vspace{1\baselineskip}
\begin{lstlisting}
    wf:wire(#jq{target=n2ostatus,method=[show,select],args=[]}).
\end{lstlisting}
\vspace{1\baselineskip}

which turns to:

\vspace{1\baselineskip}
\begin{lstlisting}
    $('#n2ostatus').show(); $('#n2ostatus').select();
\end{lstlisting}

\subsection{Async Processes \bf{wf:async}}
Creates Erlang processes communicating with the primary page process by sending messages.
For redirecting all updates and wire actions to the page process {\bf wf:flush} should be called.
Usually you send messages to Async processes over N2O message bus but you can use any.

\subsection{Message Bus {\bf wf:reg} and {\bf wf:send}}
N2O uses GProc process registry for managing async processes pools.
It is used as a PubSub message bus for N2O communications, but later you can switch to robust RabbitMQ.
You can assign a process to the pool with {\bf wf:reg} and send a message to the pool with {\bf wf:send}.

\subsection{Parse URL and Context parameters {\bf wf:q} and {\bf wf:qs}}
These are used to extract URL parameters or read from the process context. {\bf wf:q} extracts variables
from the context stored by controls postbacks and {\bf wf:qs} extracts variables from HTTP forms.

\subsection{Render {\bf wf:render}}
Renders elements or actions with common render.

\subsection{Redirects {\bf wf:redirect}}
Redirects are not implemented with HTTP headers but with JavaScript action modifying {\bf window.location}.
This saves login context information and sends it in the first packet upon establishing a WebSocket connection.

\subsection{Session Information {\bf wf:session}}
Stores any session information in ETS tables. Use {\bf wf:user}, {\bf wf:role} for
login and authorization. See {\bf AVZ} library.

\subsection{Bridge information {\bf wf:header} and {\bf wf:cookie}}
You can read and issue cookie and headers information using internal Web-Server routines.
You can also read peer IP with {\bf wf:peer}.

